/**
 * @author Mar Canet (mar.canet@gmail.com)
 *
 * Based in ofxProjectorBlend shader: https://github.com/Flightphase/ofxProjectorBlend
 * 
 */

THREE.EdgeBlendingShader = {

	uniforms: {
		"BlendPower":    		{ type: "f", value: 0.9 },
		"BlendPower2":    		{ type: "f", value: 0.9 },
		"SomeLuminanceControl": { type: "f", value: 0.3 },
		"SomeLuminanceControl2": { type: "f", value: 0.3 },
		"GammaCorrection":    	{ type: "v3", value: new THREE.Vector3( 0.3,0.3,0.3 ) },
		"GammaCorrection2":    	{ type: "v3", value: new THREE.Vector3( 0.3,0.3,0.3) },
		

		"tDiffuse": 			{ type: "t", value: null },
		"width":    			{ type: "f", value: 1.0 },
		"height":    			{ type: "f", value: 1.0 },

		"OverlapLeft":    		{ type: "f", value: 0.0 },
		"OverlapRight":    		{ type: "f", value: 0.0 },
		"OverlapTop":    		{ type: "f", value: 0.0 },
		"OverlapBottom":    	{ type: "f", value: 0.0 },

		"BlackOutLeft":    		{ type: "f", value: 0.0 },
		"BlackOutRight":    	{ type: "f", value: 0.0 },
		"BlackOutTop":    		{ type: "f", value: 0.0 },
		"BlackOutBottom":   	{ type: "f", value: 0.0 },
		"SolidEdgeEnable":    	{ type: "f", value: 0.0 },
		"SolidEdgeColor":    	{ type: "v4", value: new THREE.Vector4( 1.0, 1.0,1.0, 1.0 ) },
		"texCoordOffset":    	{ type: "v2", value: new THREE.Vector2( 0, 0 ) },
		//"projectors":    		{ type: "f", value: 0.2},
		"threshold":    		{ type: "f", value: 0.0 }
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [
		"uniform sampler2D tDiffuse;",
		"varying vec2 vUv;",
		"uniform float width;",
		"uniform float height;",
		"uniform float OverlapLeft;",
		"uniform float OverlapRight;", 
		"uniform float OverlapTop;",
		"uniform float OverlapBottom;",
		"uniform float BlackOutLeft;",
		"uniform float BlackOutRight;", 
		"uniform float BlackOutTop;",
		"uniform float BlackOutBottom;",
		"uniform float BlendPower;",
		"uniform float SomeLuminanceControl;",
		"uniform vec3  GammaCorrection;",
		"uniform float BlendPower2;",
		"uniform float SomeLuminanceControl2;",
		"uniform vec3  GammaCorrection2;",
		"uniform float SolidEdgeEnable;",
		"uniform vec4  SolidEdgeColor;",
		"uniform vec2  texCoordOffset;",
		"uniform float projectors;",
		"uniform float threshold;",

		"vec4 drawSmoothEdge(float loc, float extend, float blePow, float lumCon, vec3 gamma)",
		"{",
		"	vec4 edge;",
		"	float curve;",
		"	curve = loc / extend;",
		"	curve = (curve < 0.5) ?", 
		"		lumCon * pow(2.0 * curve, blePow)", 
		"		: ",
		"		1.0 - (1.0 - lumCon) * pow(2.0 * (1.0 - curve), blePow);",
		"	edge = vec4(pow(curve, 1.0 / gamma.r),",
		"				pow(curve, 1.0 / gamma.g),",
		"				pow(curve, 1.0 / gamma.b),",
		"				1.0);",
		"	return edge;",
		"}",

		
		"vec4 drawSmoothEdges(in vec4 overlap, in vec4 blankout, in vec4 color)",
		"{",
		"	vec2 xy = vUv;//gl_TexCoord[0].xy;",
		"	vec2 xy_t = xy + texCoordOffset.xy;",
		"	vec4 blank = vec4(0.0,0.0,0.0,0.0);",
		"	float proj2 = 1.0;// ... this basically defines a limit;",
		"	float thresh = proj2 * width + overlap.x;//(projectors - overlap.x) * width;",
		"	float blnPwr = (xy_t.x > thresh) ? BlendPower: BlendPower2;",
		"	float slc    = (xy_t.x > thresh) ? SomeLuminanceControl: SomeLuminanceControl2;",
		"	vec3 gamma   = (xy_t.x > thresh) ? GammaCorrection: GammaCorrection2;",
		"	slc += 0.5;",
		"	vec4 sebImage = ",
		"		(blankout.x + overlap.x > xy.x) ?", 
		"			(blankout.x > xy.x) ?", 	
		"				blank 							//leftBlankout",
		"			:	(blankout.z + overlap.z > xy.y) ?",
		"					(blankout.z > xy.y) ? ",
		"						blank					//leftBottomBlankOut",
		"					: 	texture2D(tDiffuse, xy_t) 	*		//leftBottomBlend",
		"						drawSmoothEdge(xy.x - blankout.x, overlap.x, blnPwr, slc, gamma) * ",
		"						drawSmoothEdge(xy.y - blankout.z, overlap.z, blnPwr, slc, gamma)",
		"				: 	(height - blankout.w - overlap.w < xy.y) ?  ",
		"						(height - blankout.w < xy.y) ? ",
		"							blank				//leftTopBlankout",
		"						: 	texture2D(tDiffuse, xy_t) 	*	//LeftTopBlend",
		"							drawSmoothEdge(xy.x - blankout.x, overlap.x, blnPwr, slc, gamma) * ",
		"							drawSmoothEdge(height - blankout.w - xy.y, overlap.w, blnPwr, slc, gamma)",	
		"							:	texture2D(tDiffuse, xy_t) *		//leftBlankout",
		"						drawSmoothEdge(xy.x - blankout.x, overlap.x, blnPwr, slc, gamma)// + vec4(0.5, 0, 0.5, 0)	// debug: magenta",
		"		:	(width - blankout.y - overlap.y < xy.x) ?", 
		"				(width - blankout.y < xy.x) ? ",
		"					blank						//rightBlankout",
		"				:	(blankout.z + overlap.z > xy.y) ?",
		"						(blankout.z > xy.y) ? ",
		"							blank 				//rightBottomBlankout",
		"						: 	texture2D(tDiffuse, xy_t) 	*	//rightBottomBlend",
		"							drawSmoothEdge(width - blankout.y - xy.x, overlap.y, blnPwr, slc, gamma) *",
		"							drawSmoothEdge(xy.y - blankout.z, overlap.z, blnPwr, slc, gamma)",
		"					:	(height - blankout.w - overlap.w < xy.y) ?",
		"							(height - blankout.w < xy.y) ? ",
		"								blank 			//rightTopBlankout",
		"							:	texture2D(tDiffuse, xy_t) * //rightTopBlend",
		"								drawSmoothEdge(width - blankout.y - xy.x, overlap.y, blnPwr, slc, gamma) * ",
		"								drawSmoothEdge(height - blankout.w - xy.y, overlap.w, blnPwr, slc, gamma)",
		"						:	texture2D(tDiffuse, xy_t) * 	//rightBlend",
		"							drawSmoothEdge(width - blankout.y - xy.x, overlap.y, blnPwr, slc, gamma)// + vec4(0, 0, 0.5, 0)	// debug: blue",
		"			:	(blankout.z + overlap.z > xy.y) ?",
		"					(blankout.z > xy.y) ? ",
		"						blank 					//BottomBlankout",
		"					: 	texture2D(tDiffuse, xy_t) * 		//BottomBlend",
		"						drawSmoothEdge(xy.y - blankout.z, overlap.z, blnPwr, slc, gamma)",
		"				:	(height - blankout.w - overlap.w < xy.y) ?",
		"						(height - blankout.w < xy.y) ? ",
		"							blank 				//TopBlankout",
		"						:	texture2D(tDiffuse, xy_t) * 	//TopBlend",
		"							drawSmoothEdge(height - blankout.w - xy.y, overlap.w, blnPwr, slc, gamma)",		
		"							:	texture2D(tDiffuse, xy_t);// + vec4(0, 0.5, 0.5, 0);	// debug: teal",
		"	return sebImage;",
		"}",
		
		
		"vec4 drawSolidEdges(vec4 overlap, vec4 blankout, vec4 color)",
		"{",	
		"	vec2 xy = vUv;//gl_TexCoord[0].xy;",
		"	vec2 xy_t = xy + texCoordOffset.xy;",
		"	vec4 blank = vec4(0.0,0.0,0.0,0.0);	",	
		"	vec4 edgeImage =",
		"			(blankout.x + overlap.x > xy.x) ?",
		"				(blankout.x > xy.x) ?",
		"					blank				//leftBlankout",
		"				:	(blankout.z + overlap.z > xy.y) ?",
		"						(blankout.z > xy.y) ?",
		"							blank			//leftBottomBlankout",
		"						: 	color			//leftBottomColor",
		"					: 	(height - blankout.w - overlap.w < xy.y) ?",
		"							(height - blankout.w < xy.y) ?",
		"								blank 		//leftTop",
		"							: 	color 		//leftTopColor",
		"						:	color			//leftColor",
		"			:	(width - blankout.y - overlap.y < xy.x) ?",
		"					(width - blankout.y < xy.x) ?",
		"						blank				//rightBlankout",
		"					:	(blankout.z + overlap.z > xy.y) ?",
		"							(blankout.z > xy.y) ?",
		"								blank 		//rightBottomBlankout",
		"							: 	color		//rightBottomColor",
		"						:	(height - blankout.w - overlap.w < xy.y) ?",
		"								(height - blankout.w < xy.y) ?", 
		"									blank 	//rightTopBlankout",
		"								:	color 	//rightToColor",
		"							:	color 		//rightColor",
		"				:	(blankout.z + overlap.z > xy.y) ?",
		"						(blankout.z > xy.y) ? ",
		"							blank 			//BottomBlankout",
		"						: 	color			//BottomColor",
		"					:	(height - blankout.w - overlap.w < xy.y) ?",
		"							(height - blankout.w < xy.y) ? ",
		"								blank 		//TopBlankout",
		"							:	color		//TopColor",
		"						:	texture2D(tDiffuse, xy_t);	",	
		"	return edgeImage;",
		"}",
		


		"void main (void)",
		"{",
		"	vec4 overlap = vec4 (OverlapLeft, OverlapRight, OverlapBottom, OverlapTop);",
		"	vec4 blankout = vec4 (BlackOutLeft, BlackOutRight, BlackOutBottom, BlackOutTop);",
		
		"	gl_FragColor = (SolidEdgeEnable == 1.0) ?",
		"			drawSolidEdges(overlap, blankout, SolidEdgeColor)",
		"		:	drawSmoothEdges(overlap, blankout, SolidEdgeColor);",
		
		"}"
	].join("\n")

};
